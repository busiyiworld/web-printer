import type { MaybeMultiURL, PageInfo, Plugin } from "@web-printer/core"
import { delay } from "@web-printer/core"

export default function (options: {
  /**
   * url of website page generated by mdbook, this page must have sidebar outline
   * @example
   * - "https://vitepress.vuejs.org/guide/"
   * - "https://vuejs.org/guide/introduction.html"
   * - {
   *    Guide: "https://vuejs.org/guide/introduction.html",
   *    API: "https://vuejs.org/api/application.html"
   *  }
   */
  url: MaybeMultiURL
}): Plugin {
  const { url } = options
  if (!url) throw new Error("url is required")
  return {
    async fetchPagesInfo({ context }) {
      async function fecth(url: string, group?: string) {
        await page.goto(url)
        const data = JSON.parse(
          await page.evaluate(`
(() => {
  function genGroups(nodes, groups) {
    return nodes.reduce((acc, node, i) => {
      const paddingLeft = Number(node.style.paddingLeft.replace("px", ""))
      let selfGroup = false
      if(i!==0) {
        const interval = paddingLeft - acc.paddingLeft
        if(interval > 0) {
          if(acc.interval === 0) acc.interval = interval
          acc.groups.push(acc.title)
          selfGroup = true
        } else if(interval < 0) {
          for(let i=0; i<Math.abs(interval/acc.interval); i++) acc.groups.pop()
        }
      }

      acc.title = node.innerText
      acc.paddingLeft = paddingLeft
      acc.items.push({title: node.innerText, url: node.href, selfGroup, groups: [...acc.groups]})
      return acc
    }, {items:[], paddingLeft:0, title: "", groups, interval: 0}).items.filter(k => k.url)
  };
  const ret = [...document.querySelectorAll("#VPSidebarNav .group")].map((k,i)=> {
      const title = k.querySelector(".title")?.innerText
      if(i && !title) return []
      return genGroups([...k.querySelectorAll(".VPSidebarGroup .link")], title ? [{
        name: title,
        collapsed: !!k.querySelector(".collapsed")
      }]:[])
  }).flat()
  return JSON.stringify(ret)
})()
  `)
        ) as PageInfo[]
        if (group) {
          data.forEach(k => {
            if (k.groups) k.groups.unshift(group)
            else k.groups = [group]
          })
        }
        return data
      }
      const page = await context.newPage()
      const pagesInfo = []
      if (typeof url === "string") {
        pagesInfo.push(...(await fecth(url)))
      } else {
        for (const [k, v] of Object.entries(url)) {
          pagesInfo.push(...(await fecth(v, k)))
        }
      }
      await page.close()
      return pagesInfo
    },
    async beforePrint() {
      await delay(500)
    },
    injectStyle() {
      const style = `
    .vueschool,
    .vue-mastery-link,
    .edit-link,
    .vuejobs-wrapper {
        display: none !important;
    }

    [class*=language-] code {
        padding: 0 48px!important;
    }
    `
      return {
        style,
        contentSelector: "main"
      }
    }
  }
}
